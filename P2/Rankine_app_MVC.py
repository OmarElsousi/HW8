#region imports
import sys
from PyQt5 import QtWidgets as qtw
from PyQt5 import QtCore as qtc

# The following import references a GUI form generated (likely) by Qt Designer.
# Ui_Form is the class that sets up the widgets and layout for our main window.
from Rankine_GUI import Ui_Form

# rankineController is a custom class (defined in Rankine_Classes_MVC.py)
# that handles the application’s logic (the “Controller” in MVC).
from Rankine_Classes_MVC import rankineController

# UnitConverter is a class that handles conversions between SI and English units.
from UnitConversions import UnitConverter as UC

# The following imports allow embedding a Matplotlib plot in our PyQt5 application.
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT
from matplotlib.figure import Figure
#endregion


#region class definitions
class MainWindow(qtw.QWidget, Ui_Form):
    """
    MainWindow is the primary GUI class for this application.

    It inherits from:
    1. qtw.QWidget: A Qt widget that can act as a top-level window.
    2. Ui_Form: The class generated by Qt Designer (Rankine_GUI.py),
       which contains the setupUi method and all GUI component definitions.

    Responsibilities of MainWindow:
    - Initialize the UI.
    - Connect signals (button clicks, text edits, etc.) to event handler methods.
    - Create and manage the embedded Matplotlib canvas.
    - Instantiate a rankineController object to handle the data and logic.
    - Delegate user interactions (like calculations and unit switches) to the controller.
    """

    def __init__(self):
        """
        The constructor for MainWindow.

        This method:
        1. Calls the superclass initializers (QWidget and Ui_Form).
        2. Sets up the UI (layout, widgets).
        3. Assigns signal connections (buttons, text fields, etc.).
        4. Creates a Matplotlib canvas to display plots.
        5. Instantiates the rankineController to handle logic and calculations.
        6. Performs an initial calculation so that the user sees immediate results.
        7. Initializes tracking variables for mouse movement on the plot.
        8. Displays the main window.
        """
        super().__init__()
        self.setupUi(self)  # Sets up all UI components from Ui_Form.
        self.AssignSlots()  # Assign signals/slots (event handlers).
        self.MakeCanvas()   # Create the Matplotlib canvas and toolbar.

        # Create lists of input and display widgets that will be passed to the controller.
        # These lists help the controller manage and update GUI elements directly.
        self.input_widgets = [
            self.rb_SI,
            self.le_PHigh,
            self.le_PLow,
            self.le_TurbineInletCondition,
            self.rdo_Quality,
            self.le_TurbineEff,
            self.cmb_XAxis,
            self.cmb_YAxis,
            self.chk_logX,
            self.chk_logY
        ]
        self.display_widgets = [
            self.lbl_PHigh,
            self.lbl_PLow,
            self.lbl_SatPropLow,
            self.lbl_SatPropHigh,
            self.lbl_TurbineInletCondition,
            self.lbl_H1,
            self.lbl_H1Units,
            self.lbl_H2,
            self.lbl_H2Units,
            self.lbl_H3,
            self.lbl_H3Units,
            self.lbl_H4,
            self.lbl_H4Units,
            self.lbl_TurbineWork,
            self.lbl_TurbineWorkUnits,
            self.lbl_PumpWork,
            self.lbl_PumpWorkUnits,
            self.lbl_HeatAdded,
            self.lbl_HeatAddedUnits,
            self.lbl_ThermalEfficiency,
            self.canvas,
            self.figure,
            self.ax
        ]

        # Create the controller, passing it the references to input & display widgets.
        self.RC = rankineController(self.input_widgets, self.display_widgets)

        # Set up initial values for high and low pressure using methods below.
        self.setNewPHigh()
        self.setNewPLow()

        # Perform an initial calculation so the user sees something right away.
        self.Calculate()

        # Variables to store the last known mouse coordinates on the plot.
        self.oldXData = 0.0
        self.oldYData = 0.0

        # Finally, show the main window on screen.
        self.show()

    def AssignSlots(self):
        """
        Connects GUI components to the appropriate event-handling methods.

        Here, 'slots' means the functions that will handle user actions (signals).
        For example, clicking a button or toggling a radio button calls a method.
        """
        # When the user clicks the Calculate button, run the calculation method.
        self.btn_Calculate.clicked.connect(self.Calculate)

        # When the user toggles the radio button for Quality or THigh,
        # call SelectQualityOrTHigh (updates interface for those input options).
        self.rdo_Quality.clicked.connect(self.SelectQualityOrTHigh)
        self.rdo_THigh.clicked.connect(self.SelectQualityOrTHigh)

        # When the user finishes editing the "P High" line edit, call setNewPHigh.
        self.le_PHigh.editingFinished.connect(self.setNewPHigh)
        # Similarly for the "P Low" line edit.
        self.le_PLow.editingFinished.connect(self.setNewPLow)

        # When the user switches units to SI or English, update the units in the GUI.
        self.rb_SI.clicked.connect(self.SetUnits)
        self.rb_English.clicked.connect(self.SetUnits)

        # Whenever the user changes the XAxis or YAxis combo boxes
        # or toggles the log-scale checkboxes, update the plot.
        self.cmb_XAxis.currentIndexChanged.connect(self.SetPlotVariables)
        self.cmb_YAxis.currentIndexChanged.connect(self.SetPlotVariables)
        self.chk_logX.toggled.connect(self.SetPlotVariables)
        self.chk_logY.toggled.connect(self.SetPlotVariables)

    def MakeCanvas(self):
        """
        Creates a Matplotlib Figure and its corresponding canvas to embed in the GUI.

        1. A Figure object is created.
        2. A canvas (FigureCanvasQTAgg) is constructed to allow the figure
           to be displayed inside a Qt widget.
        3. A default axes (self.ax) is added to the figure.
        4. A NavigationToolbar2QT is created to enable typical Matplotlib
           navigation like zooming, panning, etc.
        5. The canvas and the toolbar are added to the Layout_Plot layout
           (a placeholder from the .ui file).
        6. The method also connects a mouse movement event on the canvas
           to mouseMoveEvent_Canvas for interactive feedback.
        """
        # Create a new figure. figsize is small because it will expand to fill layout.
        self.figure = Figure(figsize=(1,1), tight_layout=True, frameon=True)
        # Create a canvas that will show 'figure' in the GUI.
        self.canvas = FigureCanvasQTAgg(self.figure)
        # Create an axes to draw upon.
        self.ax = self.figure.add_subplot()
        # Add the Matplotlib navigation toolbar to our layout,
        # so the user can interact with the plot.
        self.Layout_Plot.addWidget(NavigationToolbar2QT(self.canvas, self))
        # Add the canvas itself to the layout, so it is visible.
        self.Layout_Plot.addWidget(self.canvas)

        # Connect a motion event so that when the mouse moves over the plot,
        # we can track and display the coordinates in the window title.
        self.canvas.mpl_connect("motion_notify_event", self.mouseMoveEvent_Canvas)

    def mouseMoveEvent_Canvas(self, event):
        """
        Event handler triggered whenever the mouse is moved over the Matplotlib canvas.

        Parameters:
            event: A Matplotlib event object that contains mouse coordinates.
        """
        # Only update if the x or y coordinate is not None
        # (could be None if the cursor is outside the plot area).
        self.oldXData = event.xdata if event.xdata is not None else self.oldXData
        self.oldYData = event.ydata if event.ydata is not None else self.oldYData

        # Choose appropriate units to display based on whether
        # the user selected SI or English units.
        sUnit = 'kJ/(kg*K)' if self.rb_SI.isChecked() else 'BTU/(lb*R)'
        TUnit = 'C' if self.rb_SI.isChecked() else 'F'

        # Update the main window’s title to show the coordinates.
        self.setWindowTitle(
            f's: {self.oldXData:0.2f} {sUnit}, T: {self.oldYData:0.2f} {TUnit}'
        )

    def Calculate(self):
        """
        Performs the calculation by instructing the controller to update its model.

        The controller will read the values in the input widgets, compute the
        thermodynamic properties, then update the display widgets accordingly.
        """
        self.RC.updateModel()

    def SelectQualityOrTHigh(self):
        """
        Called when the user clicks either 'Quality' or 'T High' radio button.

        This method delegates to the controller, telling it to switch which
        input is enabled (quality vs. temperature). The GUI display is updated
        so the user sees the correct input field become available or disabled.
        """
        self.RC.selectQualityOrTHigh()

    def SetPlotVariables(self):
        """
        Called whenever the user changes the X-axis or Y-axis variable
        or toggles log-scale for either axis.

        This updates the plot (via the controller) to display new data
        or a new scale (log vs. linear).
        """
        self.RC.updatePlot()

    def SetUnits(self):
        """
        Called when the user switches between SI and English units (radio buttons).

        This instructs the controller to convert existing values and labels
        to the correct system of units and redraw or recalculate as needed.
        """
        self.RC.updateUnits()

    def setNewPHigh(self):
        """
        Called when the user finishes editing the 'High Pressure' input field.

        This method:
        1. Notifies the controller about the updated high pressure value.
        2. The controller updates saturation properties and, if necessary,
           T High or other related values.
        3. Immediately refreshes the model results so the user sees updates
           without needing to click 'Calculate' again.
        """
        self.RC.setNewPHigh()
        self.RC.updateModel()

    def setNewPLow(self):
        """
        Called when the user finishes editing the 'Low Pressure' input field.

        This works similarly to setNewPHigh but applies to the low-pressure side.
        """
        self.RC.setNewPLow()
        self.RC.updateModel()


#endregion


# The typical Python pattern for running the application if this file is executed directly.
if __name__ == '__main__':
    # Create a QApplication object, which manages the GUI application's control flow.
    app = qtw.QApplication(sys.argv)

    # Instantiate the main window class.
    mw = MainWindow()

    # Set the title for the main window.
    mw.setWindowTitle('Rankine calculator')

    # Start the event loop for the application.
    # The program will keep running until the user closes the window.
    sys.exit(app.exec())
